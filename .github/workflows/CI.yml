name: CI
on:
  pull_request:
  push:
    branches: main
    tags: "*"

jobs:
  test:
    name: Julia ${{ matrix.version }} - ${{ matrix.os }} - ${{ matrix.arch }} - ${{ github.event_name }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        version:
          - "1.6"  # Earliest supported version of Julia
          - "1"    # Latest Julia release
        os:
          - ubuntu-latest
        arch:
          - x64
    env:
      K8S_CLUSTER_TESTS: "false"
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - uses: julia-actions/setup-julia@v1
        with:
          version: ${{ matrix.version }}
          arch: ${{ matrix.arch }}
      - uses: julia-actions/cache@v1
      - uses: julia-actions/julia-buildpkg@v1
      - uses: julia-actions/julia-runtest@v1
      - uses: julia-actions/julia-processcoverage@v1
      - uses: codecov/codecov-action@v3

  docs:
    name: Documentation
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: julia-actions/setup-julia@v1
        with:
          version: "1"
      - uses: julia-actions/cache@v1
      - run: |
          julia --project=docs -e '
            using Pkg
            Pkg.develop(PackageSpec(path=pwd()))
            Pkg.instantiate()'
      - run: julia --project=docs docs/make.jl
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DOCUMENTER_KEY: ${{ secrets.DOCUMENTER_KEY }}

  cluster-test:
    name: Cluster Test - Julia ${{matrix.julia-version }} - K8s ${{ matrix.k8s-version }} - minikube ${{ matrix.minikube-version }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        julia-version:
          - "1"
        # Support the latest versions of the supported releases: https://kubernetes.io/releases/.
        # These must be full version numbers including the patch.
        k8s-version:
          - "1.24.12"
          - "1.25.8"
          - "1.26.3"
        minikube-version:
          - "1.29.0"
    env:
      # Reference the HEAD commit which triggerred this workflow. By default PRs use a merge commit
      SHA: ${{ github.event.pull_request.head.sha || github.sha }}
      K8S_CLUSTER_TESTS: "true"
      IMAGE_REPO: "k8s-cluster-managers"
    steps:
      - uses: actions/checkout@v3
        with:
          ref: ${{ env.SHA }}  # Always checkout HEAD commit
          fetch-depth: 2  # To determine parent commit SHA
      - name: Determine SHAs
        id: sha
        run: |
          head_short_sha="$(git rev-parse --short HEAD)"
          parent_short_sha="$(git rev-parse --short HEAD^)"
          echo "head_short_sha=$head_short_sha" | tee -a "$GITHUB_OUTPUT"
          echo "parent_short_sha=$parent_short_sha" | tee -a "$GITHUB_OUTPUT"
          echo "HEAD_SHORT_SHA=$head_short_sha" | tee -a "$GITHUB_ENV"
          echo "PARENT_SHORT_SHA=$parent_short_sha" | tee -a "$GITHUB_ENV"
      - uses: julia-actions/setup-julia@v1
        with:
          version: ${{ matrix.julia-version }}
      - uses: julia-actions/cache@v1
      - uses: julia-actions/julia-buildpkg@v1

      # https://github.com/marketplace/actions/docker-setup-buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Allow Docker layers to persist between CI workflows. Using SHAs as our keys to allow for workflow restarts
      # to pull the correct cache data instead of returning the most recent cached data.
      # https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows#matching-a-cache-key
      - uses: actions/cache/restore@v3
        id: restore-docker-image-cache
        with:
          key: docker-image-cache-${{ steps.sha.outputs.head_short_sha }}
          path: ./images
          restore-keys: |
            docker-image-cache-${{ steps.sha.outputs.parent_short_sha }}
            docker-image-cache-
      - name: Load Docker image
        run: |
          parent_image_path="./images/$IMAGE_REPO:$PARENT_SHORT_SHA"
          if [ -f "$parent_image_path" ]; then
              docker load <"$parent_image_path"
              docker tag "$IMAGE_REPO:$PARENT_SHORT_SHA" "$IMAGE_REPO:$HEAD_SHORT_SHA"
              rm "$parent_image_path"  # Avoid storing the old image in the new cache entry
          fi
      - name: Build Docker image
        run: |
          image="$IMAGE_REPO:$HEAD_SHORT_SHA"
          docker build -t "$image" .
          echo "K8S_CLUSTER_MANAGERS_TEST_IMAGE=$image" | tee -a "$GITHUB_ENV"
      - name: Save Docker image
        run: |
          image_path="./images/$K8S_CLUSTER_MANAGERS_TEST_IMAGE"
          mkdir -p "$(dirname "$image_path")"
          docker save "$K8S_CLUSTER_MANAGERS_TEST_IMAGE" >"$image_path"
          echo "IMAGE_PATH=$image_path" | tee -a "$GITHUB_ENV"

      # Factors influencing the setup of the "local" Kubernetes cluster:
      # - Limited resources on GitHub runners only allow running a 1 pod at a time with
      #   the default minikube install (additional jobs would be stuck as "Pending")
      # - minikube restricts max CPUs per node to the number of CPUs on the host
      # - minikube "none" driver only supports a single node (due to port conflicts)
      # - minikube "docker" driver requires local-only images to present on the node where
      #   it is used (all nodes in practice)
      - name: Set up minikube
        uses: manusa/actions-setup-minikube@v2.7.2
        with:
          # https://github.com/kubernetes/minikube/releases
          minikube version: v${{ matrix.minikube-version }}
          # Needs to match the tags format: https://github.com/kubernetes/kubernetes/tags
          kubernetes version: v${{ matrix.k8s-version }}
          driver: docker
          start args: --nodes=2 --cni=kindnet

      # To use a Docker image in the cluster it must first be made available to the cluster
      # nodes. In single node clusters the easy way to do this with the Docker driver would
      # be to use `minikube docker-env` but since we're using multi-node cluster we have to
      # take an alternate approach. The recommended way is to use the registry addon but
      # requires more setup than the current approach of directly transferring the image to
      # each of the nodes.
      - name: Push image to node(s)
        run: |
          for node in $(minikube node list | cut -f1); do
              echo "Transfering image to node $node..."
              cat "$IMAGE_PATH" | minikube ssh --node $node --native-ssh=false -- docker load
          done

      - uses: julia-actions/julia-runtest@v1
      - uses: julia-actions/julia-processcoverage@v1
      - uses: codecov/codecov-action@v3

      # https://github.com/actions/cache/tree/main/save#always-save-cache
      - uses: actions/cache/save@v3
        if: always()
        with:
          key: ${{ steps.restore-docker-image-cache.outputs.cache-primary-key }}
          path: ./images
